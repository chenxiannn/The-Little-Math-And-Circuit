### 1.从电容谈起

还记得中学物理中学过的电容不，有的会想起C这个符号，有的会记起阻直流通交流，那我们从电容器最基本的定义开始：电容是指物体容纳电荷的能力，简单点说就是，能储存多少电荷量，可以把电容器想象成一个储存电荷的一个大池子，电荷可以通过导线不停地流入或者流出这个池子，池子越大，那储存的电荷量也就越多，也就意味着电容越大，如果1所示。

![](/assets/MathCircuit_S2_P0.png)

图1.电容与水池对比图

电荷在电容里累积的电荷量为Q（假设电容初始电荷为0），累积的电荷在电容两端产生电势差称为电容电压U，U与Q的关系是一个比例关系C（就是电容值）。如果简单理解的话，Is电流源相当于水泵，Q相当于池子的水量，U相当于水深，当水深U一定的时候，容纳的水量越多，说明池子越大，也就是意味着电容值C越大。I电流就相当于水管里的流速，I越大，说明往池子里充水速度越快，这就是Q变化率越快。于是把刚刚这段话变成公式，我们得到下面的式子：

![](/assets/MathCircuit_S2_E0.png)

其中：Q对应电荷量，U对应电容电压，I对应电流。

### RC电路

在这里电流源Is给电容C充电的电路里，如果一切条件理想化，那电容上的电压U会一直上升到无穷大，电容越大上升的速度越慢，Is越大，上升的速度越快。

如果我们将电流源Is变为电压源Us，同时在回路里加入一个电阻R，如果2所示，现在想问一下，电容C上的电压会怎么变化呢？？

![](/assets/MathCircuit_S2_P1.png)

图2.RC充电电路

我们一步步来思考这个问题，首先，如果R为0的话，那会怎么样？电压源与电容并联，那电容会瞬间从0充满电压Us。下面加入电阻R，刚开始电容上电压为0，整个回路的充电电流就是Us/R，随着电容的电压Uc升高，这个充电电流会慢慢变小（Us-Uc）/R，也就是说随着电容电压的升高，充电的速度会越来越慢，最终稳定在Us电压，如果手动画一下的话，那大概走势如图3所示。是不是很像指数函数的变化，我们可以用指数函数去拟合一通。

![](/assets/MathCircuit_S2_P2.png)

图3.电容电压变化图

如果用数学去表达刚刚描述这个动态过程的变化，该怎么做呢？？首先电源电压等于电阻上的电压加上电容电压，然后电阻上的电流等于电容的电流，电容上的电流等于电容电压的变化率与电容之积，将这几句话用数学表达一下就是下面的数学公式。

![](/assets/MathCircuit_S2_E2.png)

有没有发现呀？？？我们的微分方程出来了，就是一个RC电路。关于微分方程的求解，高等数学里专门写了一章去求微分方程的解，总之噼里啪啦一大堆，最后做题的时候，一顿代公式，什么齐次非齐次通解之类的，甚是烦恼，最后终于算出下面的解来：

![](/assets/MathCircuit_S2_E1.png)

玩电子，怎么可能会被数学搞爬下，有没有什么好方法去简化这个求解过程呢，当然有啦。我们看电容Uc最终的稳态电压是Us，然后就是Uc的动态变化趋势，R变大，那阻碍能力更强，C变大的话那意味着池子会变得更大，这个都会变慢，所以有一个时间常数跟RC相关，最终决定Uc的动态变化趋势。

设定：Us=1V，R=1k欧，C=1000uF，Uc初始电压=0，Uc电压的动态变化过程如图3所示。RC=1ms，这个称为RC电路的时间常数，从图3中我们得到，1倍时间常数到0.6513Us，2倍时间常数到0.8784Us，3倍时间常数到0.9576Us，4倍时间常数到0.9852Us。

![](/assets/MathCircuit_S2_P3.png)

图3.RC动态过程

### RC电路仿真

RC一阶电路，我们在计算机里如何仿真？？？

![](/assets/MathCircuit_S2_E3.png)

Uc的导数，还记不记得，我们高等数学里是怎么算的？？？

![](/assets/MathCircuit_S2_E4.png)

在高等数学里，利用极限来得到导数，当我们用计算机仿真的时候，是反向来用把导数离散化，这样我们就可以把第一个式子离散化为下式

![](/assets/MathCircuit_S2_E5.png)

看到上面的式子了不，里面我们知道t时刻的值，就可以通过t时刻的值，去计算t+deltaT时候的值，这就是差分仿真模型。

于是根据上面的式子，我们就可以用matlab写代码仿真RC电路的动态过程，如图1所示。

```
R=1e3;%1000欧
C=1e-6;%1uF

dt=100e-6;%delta T 时间
T=5e-3;%仿真时间长度
t=0:dt:T;%时间轴
Us=ones(length(t),1);%1V
Uc=zeros(length(t),1);
for k=1:1:length(t)-1
    Uc(k+1)=Uc(k)+(Us(k)-Uc(k))*dt/(R*C);
end

plot(t,Uc)
grid on
xlabel('t/s')
ylabel('Uc/V')
```

![](/assets/MathCircuit_S3_P0.png)

图1.RC电路动态仿真图

刚刚离散化的方程就是差分方程，整个计算机仿真动态系统都是基于这个差分方程来做的，如果想仿真精确一点，把仿真步长dt减小一点，但是意味着仿真时间会加长，如果想仿真快点，那就将dt设置长一些。

不管多么复杂的电路，都可以这样仿真，整个Simulink的底层仿真机制，也是这样玩的，都是基于差分方程做，分定步长和变步长两种玩法。

### 



